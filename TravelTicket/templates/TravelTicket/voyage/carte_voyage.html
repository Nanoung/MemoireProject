<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Carte avec itinéraire</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <style>
        #map {
            height: 400px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <script>
        const points = JSON.parse('{{ points_json|escapejs }}'); // points = [[lat, lon], [lat, lon], ...]
        const vehiclePosition = JSON.parse('{{ vehicle_position|escapejs }}'); // [lat, lon]
        const vehicleAddress = '{{ adresse|escapejs }}';
        const map = L.map('map');
        const bounds = [];

        // Fonction pour obtenir l'itinéraire réel avec OSRM (gratuit, sans clé API)
        async function getRouteFromOSRM(coordinates) {
            console.log('Tentative de récupération de l\'itinéraire avec OSRM...');
            console.log('Coordonnées:', coordinates);
            
            try {
                // Convertir les coordonnées au format OSRM lon,lat;lon,lat
                const osrmCoordinates = coordinates.map(coord => `${coord[1]},${coord[0]}`).join(';');
                const url = `https://router.project-osrm.org/route/v1/driving/${osrmCoordinates}?overview=full&geometries=geojson`;
                
                console.log('URL OSRM:', url);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`Erreur OSRM: ${response.status}`);
                }

                const data = await response.json();
                console.log('Données OSRM reçues:', data);
                
                if (data.routes && data.routes.length > 0) {
                    return {
                        features: [{
                            geometry: data.routes[0].geometry,
                            properties: {
                                segments: [{
                                    distance: data.routes[0].distance,
                                    duration: data.routes[0].duration
                                }]
                            }
                        }]
                    };
                }
                
                return null;
            } catch (error) {
                console.error('Erreur lors de la récupération de l\'itinéraire OSRM:', error);
                return null;
            }
        }

        // Ajouter les marqueurs de l'itinéraire
        points.forEach((coords, index) => {
            let markerColor;
            let popupText;
            
            if (index === 0) {
                // Premier point en vert
                markerColor = 'green';
                popupText = `Départ`;
            } else if (index === points.length - 1) {
                // Dernier point en rouge
                markerColor = 'red';
                popupText = `Arrivée`;
            } else {
                // Points intermédiaires en orange
                markerColor = 'orange';
                popupText = `Étape ${index + 1}`;
            }
            
            // Créer une icône colorée
            const colorIcon = L.divIcon({
                className: 'custom-marker',
                html: `<div style="
                    background-color: ${markerColor};
                    width: 20px;
                    height: 20px;
                    border-radius: 50%;
                    border: 2px solid white;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                "></div>`,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            
            const marker = L.marker(coords, { icon: colorIcon })
                .addTo(map)
                .bindPopup(popupText);
            bounds.push(coords);
        });

        // Ajouter la position actuelle du véhicule
        if (vehiclePosition && vehiclePosition.length === 2) {
            const vehicleIcon = L.divIcon({
                className: 'vehicle-marker',
                html: `<div style="
                    background-color: #007bff;
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    border: 3px solid white;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.4);
                    animation: pulse 2s infinite;
                ">
                <svg viewBox="0 0 24 24" fill="#007bff" width="24" height="24">
                    <path d="M18.92 6.01C18.72 5.42 18.16 5 17.5 5H15V4C15 3.45 14.55 3 14 3H10C9.45 3 9 3.45 9 4V5H6.5C5.84 5 5.28 5.42 5.08 6.01L3 12V20C3 20.55 3.45 21 4 21H5C5.55 21 6 20.55 6 20V19H18V20C18 20.55 18.45 21 19 21H20C20.55 21 21 20.55 21 20V12L18.92 6.01ZM6.5 16C5.67 16 5 15.33 5 14.5S5.67 13 6.5 13 8 13.67 8 14.5 7.33 16 6.5 16ZM17.5 16C16.67 16 16 15.33 16 14.5S16.67 13 17.5 13 19 13.67 19 14.5 18.33 16 17.5 16ZM5 11L6.5 6.5H17.5L19 11H5Z"/>
                </svg>
                
                </div>
                <style>
                    @keyframes pulse {
                        0% { transform: scale(1); }
                        50% { transform: scale(1.2); }
                        100% { transform: scale(1); }
                    }
                </style>`,
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
            
            L.marker(vehiclePosition, { icon: vehicleIcon })
                .addTo(map)
                .bindPopup(`
                    <strong>Position actuelle</strong><br>
                    Latitude: ${vehiclePosition[0]}<br>
                    Longitude: ${vehiclePosition[1]}<br>
                    Adresse: ${vehicleAddress}
                `);
            
            // Ajouter la position du véhicule aux bounds pour l'affichage
            bounds.push(vehiclePosition);
        }

        // Créer l'itinéraire
        async function createRoute() {
            if (points.length < 2) {
                console.warn('Au moins 2 points sont nécessaires pour créer un itinéraire');
                // Si pas d'itinéraire, centrer sur la position du véhicule ou les points disponibles
                if (bounds.length > 0) {
                    if (bounds.length === 1) {
                        map.setView(bounds[0], 15);
                    } else {
                        map.fitBounds(bounds);
                    }
                }
                return;
            }

            const routeData = await getRouteFromOSRM(points);
            
            if (routeData && routeData.features && routeData.features.length > 0) {
                // Utiliser l'itinéraire réel de OSRM
                const routeCoordinates = routeData.features[0].geometry.coordinates;
                // Convertir de [lon, lat] vers [lat, lon] pour Leaflet
                const leafletCoordinates = routeCoordinates.map(coord => [coord[1], coord[0]]);
                
                const polyline = L.polyline(leafletCoordinates, { 
                    color: 'green', 
                    weight: 5 
                }).addTo(map);
                
                map.fitBounds(polyline.getBounds());
                
                // Optionnel : afficher la distance et la durée
                const route = routeData.features[0].properties;
                if (route.segments && route.segments.length > 0) {
                    const distance = (route.segments[0].distance / 1000).toFixed(2); // en km
                    const duration = Math.round(route.segments[0].duration / 60); // en minutes
                    console.log(`Distance: ${distance} km, Durée: ${duration} min`);
                }
            } else {
                // Fallback : utiliser une polyline simple en cas d'erreur
                console.log('Utilisation d\'une polyline simple (fallback)');
                const polyline = L.polyline(bounds, { color: 'green', weight: 5 }).addTo(map);
                map.fitBounds(polyline.getBounds());
            }
        }

        // Ajouter la couche de tuiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap',
        }).addTo(map);

        // Créer l'itinéraire
        createRoute();
    </script>
</body>
</html>